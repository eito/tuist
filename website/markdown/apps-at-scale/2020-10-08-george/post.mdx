---
title: '#6 George Tsifrikas - xxxx'
categories: [Tuist, Workable]
excerpt: 'xxx'
header_image: 'https://unsplash.com/photos/CCLyr_m4emY/download?force=true&w=1920'
interviewee_name: 'George Tsifrikas'
interviewee_twitter_handle: 'gtsifrikas'
interviewee_avatar: https://pbs.twimg.com/profile_images/1201614336004898816/vI8KZmCr_400x400.jpg
community_topic: https://community.tuist.io/t/franzs-interview/92
---

In this new post of our "Apps at scale" series, we interview George Tsifrikas, iOS team lead at Workable.

## Team structure

### How are the teams structured?

The engineering teams at Workable are formed per a specific area in our product (video interviews, referrals, core etc..) with the exception of the mobile team. The mobile team is responsible for iOS and Android apps, it develops all the features that make sense to be on the mobile app and is not separated into feature squads.

### How many engineers work on features and how many take care of the infrastructure of your projects?

I hope some time in the future to have a dedicated mobile infrastructure team but we are not there yet. We are a small iOS team so all of us get to do features and infrastructure for our app.

### How do designers and developers collaborate?

When we plan a new feature, our designer has a leeway of two weeks before we start implementing a feature. During that time, our designer and the mobile platforms leads we discuss how it could be implemented and any potential constraints. During the two week period before the implementation there is a lot of back and forth mainly in the form of comments in Figma.
Upon starting the implementation of a feature we may change a few things here and there, maybe we couldn’t predict a use case but almost always we stick to the design we started with. In the middle of the sprint we do some catch up between Android, iOS and our designer to showcase our progress and align some details between the platforms that we may have missed. Also at that time we correct some UI/UX issues that may come up. Generally, throughout the sprint our designer receives staging builds and she gives us feedback if we have missed something.

## Project

### What led you to modularize your app?

The one major thing was and mainly still is, COMPILE TIMES. As our project grew so the compile times and waiting 2 minutes for an incremental build and 8 minutes for a clean build was just painful and it was killing productivity.

### What did you learn during the process of modularizing the app?

It was a way bigger undertaking of an effort that we had in our minds when we started designing the modularisation. First, we did a lot of research on how the code should be separated and this has to be done as well as possible so all the effort won’t go to waste. Not separating the code in a proper way it may even increase the compile times of clean builds.
Then, we tried to find out how we will support the modularisation effort in terms of the organisation of the project. We didn’t want to create each module by hand each in a separate xcode project because for each module we would have to pass all the build settings and how these are connected between them by hand which would make the whole configuration tiresome and prone to errors. So, we used CocoaPods with custom templates which we had declared our module once and everything worked (almost). We had to change a lot of build settings in the Podfile and do some other hacks in order to have IBDesignable to render in the storyboards for example. Right now we are in the process of evaluating Tuist.
When you start splitting your code you want to do it incrementally, especially if it is a large codebase. So, we started from the Core module which has swift extensions, networking and almost everything that is shared between every feature. We tried to keep Core-like modules in small numbers so right now, we have, WorkableUIKit, UIComponents, Models, ModelsDecoding, Interfaces, Event (our first feature module!) and Inject.

### Have you developed any core module that you would like to share with the industry?

When you try to split code between modules in order to achieve fast build time you need to reduce the interdependencies in code-level and module-level. For example, you have a shop app that shows a product listing and you add the product to cart and start the checkout process. Let’s assume that the product listing functionality is implemented in the Product module and the checkout in the Checkout module. Ideally you don’t want the Product module to know anything about the checkout module, not even it’s existence, except how to call it. In our case we have a dependency inversion layer that we have all the public protocols we want to share between our modules, so in the previous example the Product module can import Interfaces and use the functionality from the Checkout module, right?
Almost, we need an instance for the concrete class inside the Checkout module that implements the protocol from Interfaces.
In our Workable app until then we were doing dependency injection using constructors, sometimes we weren’t very diligent about it or we didn’t pass the dependencies from the root (AppDelegate). So, we needed a solution that is very very easy to use and it didn’t feel like a chore. So, we created our own dependency injection library Inject. Inject uses property wrappers to.. well.. Inject properties anywhere you want by simply writing @Injected in front of the property.

### Can you tell us more about how you use property wrappers to do dependency injection?

Let’s assume you have the following property in your code:
@Injected var fooInstance: Foo
Firstly, Foo must be a protocol.
How Inject in our app finds the implementation of Foo? In our AppDelegate when the app starts we register to Inject all dependencies. But we found out when you do runtime registering and dependency resolving you will encounter two major issues.
The first one is that you may have dependency cycles without realizing it. Let’s say we have Foo Bar protocols with FooImpl and BarImpl. If you use in FooImpl an injected property of Bar and in BarImpl and injected property of Foo you will have a dependency cycle and while your app compiles, it will crash from stack overflow when it tries to use one of either of these classes. The solution for this was to create a little analyzer that uses Swift’s mirroring and does DFS throughout the dependency graph looking for cycles. If it finds one it shows you the cycle so to break it.

The second one was that you may again use the: @Injected var fooInstance: Foo and never registered how the Foo is made. Again the app will compile but it will crash from Inject saying that it didn’t find a way to instantiate the Foo property. The solution for that is a little linter that runs from xcode, like SwiftLint for example, parses your codebase and finds out for each Injected property if it is registered. If it finds out that one is not, it shows an xcode error directly on the line for the unregistered dependency prompting you to register it.

It really made it very enjoyable to use dependencies correctly and everywhere.

We hope to make it open source very very soon!

## Code

### Could you briefly describe the architecture of your app and the paradigms that you follow?

We’re big fans of reactive programming and we’re using RxSwift from the start of the app. So all the data flows are done by observables. Each feature we write is using RxMVVM which enables us to write very comprehensive tests especially for the logic of each screen. For each feature we have an entry point, for example to compose a new email from the candidate screen all we have to do is, `emailComposer.new(forCandidate:) -> Observable<Void>` , note email composer is injected to the candidate screen.
Also, we are using our own Swift Error handler to have uniform error handling across the app.

### How do you ensure consistency across the codebase (style, architecture)?

Nothing fancy here, we try to document everything we can, Swift style guide, Code architecture, How we test and everything we can think of. Right now that we’re hiring it will prove very useful for the new members of our team. We enforce the styling of the code with SwiftLint.

## Processes/Workflows

### How is the process since there’s an idea for a feature until it lands on the main branch (e.g. master)?

You can think of our apps as an extension of the Workable desktop app. So, when we as a company decide to do a new feature we decide which aspects make sense to be on the mobile apps. Our designer along with the mobile team leads start working on the feature at least 2 weeks before it’s planned start date. After that we start to do design meetings and we start implementing the feature. Each piece of work is closed to our main branch through a PR, it doesn’t have to be complete, just not to break existing functionality. We try to keep small PRs so not to spend much time reviewing big changes. We can close PRs frequently because we use local feature flags. That means we can start a new feature behind a flag and we ship unfinished work but the end user never gets to see that work.
We use TestFlight to distribute staging builds to the designers and Product Managers through a custom pipeline created in Jenkins. So, as developers, we get frequent feedback and that lets us quickly fix things and iterate over and over.
After we finish a feature, the PM that is responsible for this feature green-light it and we ship it to the next release.

### How do you define feature flags? Do you use a service for that or is there an in-house solution?

The feature flags are just boolean values inside a plist file. We do not use them for A/B testing or remote launch of a feature. These are only for our convenience. It help us avoid merging huge branches with many conflicts between each other and each developer gets to work with the more “real” version of the code.

### When do you consider a feature “shippable”?

A feature is shippable when our designer has approved it also our PM and we have agreed on a timeline with other teams in case there is an inter-dependency. Also, for important features a feature is shippable when we have fully end-to-end automated tests.

## Testing

### What’s your testing strategy?

We try to adhere as much as we can to the Martin Fowler’s “the practical testing pyramid”. For us, that means that we do a little amount of end-to-end tests using Appium which for us work and as integration tests. We try to have 80% coverage or more with unit tests and snapshot tests in each feature which is enforced by our CI pipelines on our PRs.
Because our ETE tests are flaky sometimes and we need a lot of time to write them we checked with our QA team and found out that almost all of our regressions are API related. That means that a response from the backend changed in a not agreed upon way. So, we try to introduce another way of testing which is called contract-testing using PACT. Essentially our client and the backend have a contract that is validated in the unit tests of each platform. This type of testing is wayyy quicker than running ETE tests which take 3-4 hours. Our plan is to migrate less used features from the ETE suite to the contract suite in order to gain time and stability.

### Do you rely on third-party libraries for writing your tests?

ETE: appium
Unit tests: Quick
Snapshots: nimble snapshot (works in cohort with Quick)
Contract tests: PACT

### Do you have a QA team? If so, what’s their role?

We have a QA engineer which is responsible for both iOS & Android. The role’s responsibilities are to maintain the test suite, CI/CD pipeline, coordinate the release with other teams. The actual ETE tests are written from the mobile engineers.

### What led you to write more snapshot and PACT tests?

For years we relied heavily in end-to-end tests. All this time the app grew and along with it the ETE suite. This brought some problems with it. The suite now takes several hours to run and when you have multiple teams inside Workable that want to make their own releases each team must wait for the ETE suite to pass so to check that there are no regressions. As I mentioned above we checked with our QA engineer and found out that many of the regressions that ETE suite found were breaking API changes. So, we can use contract testing to cover this aspect of testing which is fast and stable as unit tests. Now, the suite caught and some UI regressions and for that we introduced snapshot testing in our feature development. This lets us check for any UI regression and also it generates a visual diff if something breaks!

### How do you describe your PACT tests and when do you run them?

PACT tests are written in swift. Essentially you describe the request to the backend and the expected result format and then you verify in your test that you can parse that expected response. The contract is driven from the client the backend is the consumer of that contract that must comply with. So, if any team wants to change an API that affects us they have to contact the mobile team to schedule any necessary changes. Now the test runs in each commit in an open PR and we have a status page that shows the branch of the backend repo with the branch of iOS or Android and if the contact is verified in that configuration.
You can find more here.

## Tooling

### What internal tools did you build that you are proud of?

The only internal tooling we have done so far for iOS was making CocoaPods the mechanism of declaring modules. Making this work involved a lot of time learning about libraries, frameworks, dylib and so on.. Not the best solution overall but we may not have moved on with the modules without this.

### What are your main challenges on tooling when scaling?

The lack of proper tooling from Apple. We should have a more versatile solution for building and organising our code. SPM is a step to the right direction but it’s still early.

### What are some challenges you are facing scaling up your project?

The biggest one I would say is consistency in the code. When the project gets quite big people come and go it's difficult to communicate what has been implemented and where. For example we may find the same swift extension implemented multiple times with slightly different names. Documentation and expectability on where to find something is very important.

## Last but not least

### If you started the project again, what would you do differently?

Focus more on code readability and organisation. It is very important to have a certain way to do things from the beginning, but willing to change it if it doesn’t fit to requirements any more.

### What are you the most excited about for WWDC?

From the software side I really liked widgets and how they were implemented using SwiftUI to achieve such an excellent performance (serializing the SwiftUI on disk).
From the hardware side, of course, Apple Silicon. I’m really excited for the future form factors and performance of hardware with Apple’s custom chip.

### How did COVID-19 impact your work style and processes?

Before COVID-19 almost all of our engineering was done on premises in our beautiful Athens offices. When the Greek government announced the lock downs we were promptly forced to start working from home. Until then we had one day per week that we could work from home but this is totally different from remote working. We had to change the way we communicate which translated to more documentation and everything must have a place so anyone can find it easily, less meetings and trying to have a more async way of communication.

### How do you favour asynchronous communication over synchronous one?

At first, as anyone that was working from office, had the expectation to get an answer to a question relatively quickly. When you migrate to async way of communication, at first it is a little bit difficult because you have to wait or do something else if you are blocked by someone but I believe this a small price to pay because in async you have the flexibility when to response to someone and this is less distracting from the work you focused right now. Also, if someone answers you in slack you can go back later and see the answer again (but it probably should be documented somewhere).

### How do you make sure everyone is on the same page with a distributed team setup?

In various ways, we use a knowledge base (Confluence) for features or any research that we do. For technical stuff we use markdown on github. We’re lucky our team is in the same timezone and we have many overlapping hours between us so later in the day we do a catch-up meeting to get on the same page. Our goal is to eliminate that also and use Trello or something similar in order to sync up on how we’re doing.
